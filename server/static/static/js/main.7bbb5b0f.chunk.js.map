{"version":3,"sources":["utils.js","word.js","actionTypes.js","service.js","actions.js","wordContainer.js","textSample.js","textList.js","textListContainer.js","App.js","reducers.js","index.js","store.js"],"names":["colors","string","input","hash","i","length","charCodeAt","getHash","Word","state","highlighted","showTooltip","onClickFn","setState","dismiss","props","textId","wordIndex","classifyAsNothingWordAction","closeTooltipFn","classifyWord","key","classifyWordAction","generateButton","value","Button","className","onClick","inputRef","options","this","ref","style","background","utils","wordState","word","Overlay","rootClose","onHide","target","show","placement","Tooltip","variant","map","React","Component","result","fetch","method","headers","body","JSON","stringify","then","res","json","error","catch","console","log","textSampleResultFiller","textSample","textLength","text","split","Array","fill","classification","dispatch","type","ActionTypes","fetchTextSamples","textSamples","adaptedTextSamples","fetchTextSamplesSuccess","updateTextSample","service","wordStateSelector","textData","texts","find","id","connect","ownProps","actions","TextSample","componentDidUpdate","hasChanged","getTextSampleComponent","textSampleComponent","Jumbotron","WordLabeler","buildWord","index","space","TextList","changed","Home","Container","fluid","Row","Col","lg","href","App","Navbar","bg","Brand","Nav","Link","path","sampleUpdatedReducer","action","rotating","payload","store","createStore","rotateReducer","applyMiddleware","thunk","configureStore","window","rootElement","document","getElementById","ReactDOM","render"],"mappings":"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","file":"static/js/main.7bbb5b0f.chunk.js","sourcesContent":["const colors = [\n    'C1A7FF',\n    'C2CBFF',\n    'C7FCBA',\n    'FDFEC9',\n    'FFD8B6',\n    'FEBCC2'\n];\n\nconst getHash = (input) => {\n    let hash;\n    for (let i = 0; i < input.length; i++) {\n        hash = ((hash << 5) - hash) + input.charCodeAt(i);\n        hash |= 0;\n    }\n    return hash;\n}\n\nconst getColor = (string) => {\n    if (! string) {\n        return 'none';\n    }\n    return '#' + colors[getHash(string) % 6];\n}\n\nexport default {getColor};","import React from 'react';\nimport utils from './utils'\nimport {\n    Button,\n    Overlay,\n    Tooltip,\n    Navbar,\n    Row,\n    Col,\n    Container,\n    Jumbotron\n} from 'react-bootstrap';\n\nclass Word extends React.Component {\n    state = {\n        highlighted: false,\n        showTooltip: false\n    };\n  \n    constructor() {\n        super();\n        this.inputRef = null;\n    }\n\n    onClickFn = () => {\n        this.setState({\n            highlighted: true,\n            showTooltip: !this.state.showTooltip\n        });\n    }\n\n    dismiss = () => {\n        const {textId, wordIndex, classifyAsNothingWordAction} = this.props\n        classifyAsNothingWordAction(textId, wordIndex);\n        this.closeTooltipFn();\n    }\n\n    closeTooltipFn = () => {\n        this.setState({showTooltip: false});\n    }\n\n    classifyWord = (textId, wordIndex, key) => {\n        this.closeTooltipFn();\n        this.props.classifyWordAction(textId, wordIndex, key);\n    }\n\n    generateButton = ({key, value}) => {\n        const {textId, wordIndex} = this.props;\n        return (\n            <Button className='tooltip-button' onClick={() => this.classifyWord(textId, wordIndex, key)}>{value}</Button>\n        )\n    }\n\n    render() {\n        const {options} = this.props;\n        return (\n            <>\n                <span   ref={inputRef => {this.inputRef = inputRef}} \n                        onClick={this.onClickFn}\n                        style={{background: utils.getColor(this.props.wordState)}\n                }>\n                        {this.props.word}\n                </span>\n\n                <Overlay rootClose\n                    onHide={this.closeTooltipFn}\n                    target={this.inputRef}\n                    show={this.state.showTooltip}\n                    placement=\"top\">\n\n                    <Tooltip className='customTooltip'>\n                        <Button variant=\"outline-secondary\" onClick={this.dismiss}>\n                            Dismiss\n                        </Button>\n                        <div>{options.map(this.generateButton)}</div>\n                    </Tooltip>\n                </Overlay>\n            </>\n        );\n    }\n}\n\nexport default Word;\n","export default {\n    FETCH_TEXT_SAMPLES: 'FETCH_TEXT_SAMPLES',\n    CLASSIFY_WORD: 'CLASSIFY_WORD',\n    FETCH_TEXT_SAMPLES_SUCCESS: 'FETCH_TEXT_SAMPLES_SUCCESS',\n    TEXT_SAMPLES_UPDATED: 'TEXT_SAMPLES_UPDATED'\n  };","const updateTextSample = (textId, result) => {\n    // TODO: refactor using await async\n    return fetch(`https://labeler-app.herokuapp.com/textSamples/${textId}/`, {\n        method: 'PATCH',\n        headers: {\n            'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({result})\n    }).then(res => res.json()).then(res => {\n        if (res.error) {\n            throw(res.error);\n        }\n        return res;\n    }).catch(error => {\n        console.log(error)\n    })\n\n}\n\nexport default {updateTextSample}\n","// import { createAction } from 'redux-actions';\nimport ActionTypes from './actionTypes';\nimport service from './service';\n\nconst fetchTextSamples2 = (opts) => {\n    // console.log(\"PASE\");\n}\n\nfunction textSampleResultFiller(textSample) {\n    const textLength = textSample.text.split(\" \").length;\n    const result = textSample.result || [];\n    if (result.length !== textLength) {\n        textSample.result = new Array(textLength).fill(null)\n    }\n    return textSample;\n}\n\n\nfunction fetchTextSamplesSuccess(textSamples) {\n    const adaptedTextSamples = textSamples.map(textSampleResultFiller)\n    return {type: ActionTypes.FETCH_TEXT_SAMPLES_SUCCESS, textSamples: adaptedTextSamples}\n}\n\nfunction updateTextSample(textId, result){\n    console.log(\"REEE\",result)\n    service.updateTextSample(textId,result);\n    return {type: ActionTypes.TEXT_SAMPLES_UPDATED, textId}\n\n}\n\nfunction classifyWord(textId, wordIndex, classification, dispatch) {\n    return {type: ActionTypes.CLASSIFY_WORD, textId, wordIndex, classification}\n}\n\nfunction fetchTextSamples() {\n    return(dispatch) => {\n        // dispatch(fetchProductsPending());\n        return fetch('https://labeler-app.herokuapp.com/textSamples/').then(res => res.json()).then(res => {\n            if (res.error) {\n                throw(res.error);\n            }\n            // dispatch({type:\"PEPE\"});\n            dispatch(fetchTextSamplesSuccess(res))\n            return res;\n        }).catch(error => {\n            console.log(error)\n            //     dispatch(fetchProductsError(error));\n        })\n    }\n}\n\n\n\n\nexport default {classifyWord, fetchTextSamples, updateTextSample};\n","import { connect } from 'react-redux'\nimport Word from './word'\nimport actions from './actions'\n\n\nfunction wordStateSelector(wordIndex,textId,state){\n  //(state.texts)\n  const textData = state.texts.find(text => text.id === textId);\n  if (!textData) return;\n  let result = textData.result;\n\n  return result[wordIndex];\n}\nconst mapStateToProps = (state, ownProps) => {\n  const {wordIndex,textId} = ownProps;\n  return {wordState: wordStateSelector(wordIndex,textId,state)}\n};\n\nconst mapDispatchToProps = (dispatch) => {\n    return {\n      classifyWordAction: (textId,wordIndex, key) => dispatch(actions.classifyWord(textId,wordIndex,key,dispatch)),\n      //TODO: remove this, can use the one from above\n      classifyAsNothingWordAction: (textId,wordIndex) => dispatch(actions.classifyWord(textId,wordIndex, null))\n\n    }\n  }\n\nexport default connect(\n    mapStateToProps,\n    mapDispatchToProps\n)(Word);","import React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n    Jumbotron\n} from 'react-bootstrap';\nimport Word from './wordContainer'\n\n\nclass TextSample extends React.Component {\n\n    componentDidUpdate = () => {\n      const {hasChanged, updateTextSample, textId, result} = this.props;\n      console.log(\"UPDATE\")\n      if(hasChanged){\n        updateTextSample(textId, result);\n      }\n    }\n    getTextSampleComponent = () => {\n        const {type, text, textId} = this.props;\n        let options;\n\n        // This a strategy to select the kind of textSample we are gonna show\n        // In this case is to label word by word with the following configuration\n        if (type === 'LABELER_GOOD_BAD') {\n            options = [\n                {\n                    value: 'Good word',\n                    key: 'GOOD'\n                }, {\n                    value: 'Bad word',\n                    key: 'BAD'\n                }\n            ]\n            return <WordLabeler text={text} options={options} textId={textId}/>\n        }\n    }\n\n    render() {\n        const textSampleComponent = this.getTextSampleComponent();\n        return (\n            <Jumbotron> {textSampleComponent} </Jumbotron>\n        )\n    }\n\n}\n\n// Wordlabeler could be one kind of component. Other component could be one evaluating the sentiment in the hole sentence\nclass WordLabeler extends React.Component {\n\n    buildWord = (word, index) => {\n        // TODO: refator this code to improve legibility\n        const {textId, options} = this.props;\n        const space = index === 0 ? '' : ' ';\n        return (\n            <>{space}\n                <Word options={options}\n                    textId={textId}\n                    wordIndex={index}\n                    word={word}/>\n            </>\n        )\n    }\n    render() {\n        return (\n            <span className='text'>\n              {this.props.text.split(\" \").map((word, index) => this.buildWord(word, index))} \n            </span>\n        )\n    }\n}\n\nexport default TextSample;\n","import React from 'react';\nimport TextSample from './textSample';\n\nclass TextList extends React.Component{\n     //TODO: add props validations\n    componentDidMount() {\n        const {fetchTextSamples} = this.props;\n        fetchTextSamples();\n    }\n\n    render(){\n        const {texts, updateTextSample} = this.props;\n    \n        if(texts){\n            return (\n            <>{texts.map((text, index)=>\n                <TextSample key={index} \n                    textId={text.id} \n                    text={text.text} \n                    type={text.type} \n                    hasChanged={text.changed} \n                    result={text.result}\n                    updateTextSample={updateTextSample}\n                />)\n            }</>)\n        }\n        return (<>No texts loaded</>)\n    }\n}\n\nexport default TextList;","import {connect} from 'react-redux'\nimport TextList from './textList'\nimport actions from './actions'\n\nconst mapStateToProps = state => ({texts: state.texts});\nconst mapDispatchToProps = dispatch => {\n    return {\n        fetchTextSamples: () => dispatch(actions.fetchTextSamples()),\n        updateTextSample: (textId, result) => dispatch(actions.updateTextSample(textId, result))\n    }\n}\n\nexport default connect(mapStateToProps, mapDispatchToProps)(TextList);\n","import React from 'react';\nimport './App.css';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport TextList from './textListContainer';\nimport {BrowserRouter as Router, Switch, Route} from \"react-router-dom\";\n\nimport {\n    Navbar,\n    Row,\n    Col,\n    Nav,\n    Container,\n    Jumbotron\n} from 'react-bootstrap';\n\n\nfunction App() {\n    return (\n        <Router>\n            <div className=\"App\">\n                <Navbar bg=\"light\" className='nav-bar'>\n                    <Navbar.Brand>Labeler App</Navbar.Brand>\n                    <Nav.Link href=\"/\">Home</Nav.Link>\n                </Navbar>\n                <Switch>\n                    <Route path=\"/\">\n                        <Home/>\n                    </Route>\n                </Switch>\n            </div>\n        </Router>\n    );\n}\n\nfunction Home() {\n    return (\n        <Container fluid>\n            <Row>\n                <Col lg={8}>\n                    <TextList/>\n                </Col>\n                <Col lg={4}>\n                    <Jumbotron>\n                        <h5>Use this app to label words inside texts. Click on one word and select a label.</h5>\n                        <p>For this example you can tag words as \"Good word\" \"Bad Word\". Results will be saved automatically to the database. To explore the raw results, got to:\n                            <a href='https://labeler-app.herokuapp.com/textSamples/'>https://labeler-app.herokuapp.com/textSamples/</a>\n                        </p>\n                    </Jumbotron>\n\n                </Col>\n            </Row>\n        </Container>\n    )\n}\nexport default App;\n","import ActionTypes from './actionTypes.js';\n\nconst classifyReducer = (textId,wordIndex,classification, texts) => {\n    return texts.map((text) => {\n        if(text.id === textId) {\n            text.changed = true;\n            text.result[wordIndex] = classification;\n        }\n        return text;\n    });\n}\n\nconst sampleUpdatedReducer = (textId, texts) => {\n    return texts.map((text) => {\n        if(text.id === textId) {\n            text.changed = false;\n        }\n        return text;\n    });\n}\n\nexport default (state, action) => {\n    switch (action.type) {\n        case ActionTypes.CLASSIFY_WORD:\n            return {...state,texts:classifyReducer(action.textId,action.wordIndex,action.classification, state.texts)}\n        case ActionTypes.FETCH_TEXT_SAMPLES_SUCCESS:\n            return {...state,texts:action.textSamples}\n        case ActionTypes.TEXT_SAMPLES_UPDATED:\n            return {...state,texts:sampleUpdatedReducer(action.textId,state.texts)}\n        case ActionTypes.FETCH_TEXT_SAMPLES:\n          return {\n          rotating: action.payload\n        };\n      default:\n        return state;\n    }\n};","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\nimport {Provider} from 'react-redux'\nimport configureStore from \"./store\";\n\nconst store = configureStore();\nwindow.store = store;\n\nconst rootElement = document.getElementById('root')\nReactDOM.render (\n    <Provider store={store}>\n        <App/>\n    </Provider>,\n    rootElement\n)","import {createStore, applyMiddleware} from 'redux';  \nimport rotateReducer from \"./reducers\";\nimport thunk from 'redux-thunk';\n\n\nconst configureStore = (state = { rotating: true }) => {\n  return createStore(rotateReducer,\n    state,\n    applyMiddleware(thunk)\n    );\n}\n\nexport default configureStore;"],"sourceRoot":""}